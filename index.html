<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>OFDM Satellite Simulation</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.26.2/full/pyodide.js"></script>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; max-width: 900px; margin: 0 auto; padding: 20px; background-color: #f4f7f9; color: #333; }
        h1 { color: #0056b3; }
        label { font-weight: bold; display: block; margin-top: 10px; }
        input, button, select { margin: 5px 0 10px 0; padding: 10px; border-radius: 5px; border: 1px solid #ccc; width: calc(100% - 22px); box-sizing: border-box; }
        button { background-color: #007bff; color: white; font-weight: bold; cursor: pointer; transition: background-color 0.3s; }
        button:hover { background-color: #0056b3; }
        #output { background-color: #e9ecef; padding: 15px; border-radius: 5px; white-space: pre-wrap; font-family: "Courier New", Courier, monospace; margin-top: 15px; min-height: 120px; }
        #plot { max-width: 100%; border: 1px solid #ddd; margin-top: 15px; border-radius: 5px; }
        .input-group { display: flex; flex-wrap: wrap; justify-content: space-between; gap:10px; }
        .input-group > div { flex: 1 1 30%; min-width: 200px; }
        /* MISSING 2: DATA RATE OUTPUT STYLING */
        #data-rate-output { 
            font-size: 1.2em; 
            font-weight: bold; 
            color: #007bff; 
            margin-bottom: 10px; 
            text-align: center;
            background-color: #eaf3ff; 
            padding: 10px; 
            border-radius: 5px;
        }
        .pipeline-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .pipeline-stage {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .pipeline-stage h3 {
            margin-top: 0;
            color: #007bff;
            border-bottom: 2px solid #eaf3ff;
            padding-bottom: 5px;
        }
        .viz-box {
            font-family: "Courier New", monospace;
            background-color: #f9f9f9;
            padding: 10px;
            border-radius: 5px;
            min-height: 100px;
            font-size: 0.9em;
        }
        /* Style for the data packet viz */
        #viz-encoding .data-block {
            padding: 5px;
            margin: 5px 0;
            border-radius: 3px;
            color: white;
            text-align: center;
            font-weight: bold;
            transition: width 0.5s ease-in-out;
        }
        /* Style for the OFDM grid viz */
        #viz-ofdm-grid {
            display: grid;
            gap: 2px;
            padding: 5px;
            border: 1px solid #ccc;
        }
        .grid-cell {
            width: 100%;
            padding-bottom: 100%; /* Creates square aspect ratio */
            position: relative;
        }
        .grid-cell-inner {
            position: absolute;
            top: 0; bottom: 0; left: 0; right: 0;
            font-size: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }
        .cell-data { background-color: #007bff; }
        .cell-pilot { background-color: #dc3545; }
    </style>
</head>
<body>
    <h1>OFDM Satellite Communication Simulation ğŸ›°ï¸</h1>
    <p>This tool simulates sending a text message over a satellite link using OFDM. It models noise, fading, Doppler and lets you choose FEC (Hamming or RS).</p>

    <h2>Simulation Parameters</h2>
    <div class="input-group">
        <div>
            <label for="message">Message:</label>
            <input type="text" id="message" value="Hello from Earth!">
        </div>
        <div>
            <label for="snr">SNR (dB):</label>
            <input type="number" id="snr" value="25" step="1">
        </div>
        <div>
            <label for="k_db">Rician K-factor (K<sub>dB</sub>):</label>
            <input type="number" id="k_db" value="20" step="1" min="0">
        </div>
        <div>
            <label for="doppler_norm">Normalized Doppler (f<sub>d</sub> / F<sub>s</sub>):</label>
            <input type="number" id="doppler_norm" value="0.000" step="0.0001" min="0">
        </div>
        <div>
            <label for="k_subcarriers">Number of Subcarriers (K):</label>
            <input type="number" id="k_subcarriers" value="64" step="16" min="16">
        </div>
        <div>
            <label for="fec_type">FEC Scheme:</label>
            <select id="fec_type">
                <option value="hamming">Hamming (7,4)</option>
                <option value="reed_solomon">Reed-Solomon (255,223)</option>
            </select>
        </div>
        <div>
            <label for="mod_scheme">Modulation Scheme:</label>
            <select id="mod_scheme">
                <option value="QPSK">QPSK (2 bits/sym)</option>
                <option value="BPSK">BPSK (1 bit/sym)</option>
                <option value="16QAM">16-QAM (4 bits/sym)</option>
                <option value="64QAM">64-QAM (6 bits/sym)</option>
            </select>
        </div>
        <div>
            <label for="symbol_rate">Symbol Rate (MSym/s):</label>
            <input type="number" id="symbol_rate" value="1.0" step="0.1" min="0.1">
        </div>
        </div>

    <button onclick="runSimulation()">Run Simulation</button>
    
    <div id="data-rate-output">Effective Data Rate: -</div>

    <h2>Simulation Pipeline Visualization</h2>
    <div class="pipeline-container">
        <div class="pipeline-stage">
            <h3>1. Encoding (Ground Station ğŸ“¡)</h3>
            <div id="viz-encoding" class="viz-box">
                </div>
        </div>
        <div class="pipeline-stage">
            <h3>2. Transmission (OFDM Grid)</h3>
            <div id="viz-ofdm-grid" class="viz-box">
                </div>
        </div>
        <div class="pipeline-stage">
            <h3>3. Channel (Space Link ğŸ›°ï¸)</h3>
            <img id="plot-channel" src="" alt="Channel Response">
        </div>
        <div class="pipeline-stage">
            <h3>4. Decoding (Receiver ğŸ“¡)</h3>
            <div id="viz-decoding" class="viz-box">
                </div>
            <img id="plot" src="" alt="Constellation Diagram">
        </div>
    </div>

    <div id="output">Simulation results will appear here...</div>

    <script type="text/javascript">
        let pyodide;
        const outputDiv = document.getElementById('output');
        outputDiv.innerText = "Initializing Pyodide and loading packages... This may take a moment. â³";

        async function loadPyodideAndPackages() {
            pyodide = await loadPyodide();
            await pyodide.loadPackage(['numpy','matplotlib','scipy']);
            outputDiv.innerText = "Ready to run simulation. âœ…";
            return pyodide;
        }
        const pyodidePromise = loadPyodideAndPackages();

        async function runSimulation() {
Â  Â  Â  Â  Â  Â  outputDiv.innerText = "Running simulation, please wait... âš™ï¸";
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Clear old plots and visualizations
Â  Â  Â  Â  Â  Â  document.getElementById('plot').src = "";
Â  Â  Â  Â  Â  Â  document.getElementById('plot-channel').src = "";
Â  Â  Â  Â  Â  Â  document.getElementById('viz-encoding').innerHTML = "";
Â  Â  Â  Â  Â  Â  document.getElementById('viz-ofdm-grid').innerHTML = "";
Â  Â  Â  Â  Â  Â  document.getElementById('viz-decoding').innerHTML = "";


Â  Â  Â  Â  Â  Â  const py = await pyodidePromise;

Â  Â  Â  Â  Â  Â  const snr = document.getElementById('snr').value;
Â  Â  Â  Â  Â  Â  const message = document.getElementById('message').value;
Â  Â  Â  Â  Â  Â  const k_db = document.getElementById('k_db').value;
Â  Â  Â  Â  Â  Â  const doppler_norm = document.getElementById('doppler_norm').value;
Â  Â  Â  Â  Â  Â  const k_subcarriers = document.getElementById('k_subcarriers').value;
Â  Â  Â  Â  Â  Â  const fec_type = document.getElementById('fec_type').value;
Â  Â  Â  Â  Â  Â  const mod_scheme = document.getElementById('mod_scheme').value;
Â  Â  Â  Â  Â  Â  const symbol_rate_msym = document.getElementById('symbol_rate').value;

            const pythonCode = `
import numpy as np
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import zlib, io, base64, sys, json # NEW: Added json

class CapturedOutput:
Â  Â  def __init__(self):
Â  Â  Â  Â  self.content = ''
Â  Â  def write(self, text):
Â  Â  Â  Â  self.content += text
Â  Â  def flush(self):
Â  Â  Â  Â  pass

# --- Simulation parameters from JS ---
try:
Â  Â  K = int(${k_subcarriers})
except:
Â  Â  K = 64
K = K if K>0 and (K & (K-1) == 0) else 64
CP = K // 4
pilotValue = 1+1j
P = max(1, K // 4)
allCarriers = np.arange(K)
pilotCarriers = allCarriers[::P]
if allCarriers[-1] not in pilotCarriers:
Â  Â  pilotCarriers = np.hstack([pilotCarriers, np.array([allCarriers[-1]])])
dataCarriers = np.delete(allCarriers, pilotCarriers)
if len(pilotCarriers) < 4:
Â  Â  step = max(1, K // 4)
Â  Â  pilotCarriers = allCarriers[::step]
Â  Â  if allCarriers[-1] not in pilotCarriers:
Â  Â  Â  Â  pilotCarriers = np.hstack([pilotCarriers, np.array([allCarriers[-1]])])
Â  Â  dataCarriers = np.delete(allCarriers, pilotCarriers)

mod_scheme = "${mod_scheme}"

if mod_scheme == "BPSK":
Â  Â  mu = 1
Â  Â  mapping_table = {
Â  Â  Â  Â  (0,): -1.0, 
Â  Â  Â  Â  (1,): 1.0
Â  Â  }
Â  Â  demapping_table = {
Â  Â  Â  Â  -1.0: (0,), 
Â  Â  Â  Â  1.0: (1,)
Â  Â  }
elif mod_scheme == "QPSK":
Â  Â  mu = 2
Â  Â  factor = 1.0/np.sqrt(2) 
Â  Â  mapping_table = {
Â  Â  Â  Â  (0,0): factor * (-1-1j), (0,1): factor * (-1+1j),
Â  Â  Â  Â  (1,0): factor * (1-1j), (1,1): factor * (1+1j)
Â  Â  }
Â  Â  demapping_table = {v:k for k,v in mapping_table.items()}
elif mod_scheme == "16QAM":
Â  Â  mu = 4
Â  Â  factor = 1.0/np.sqrt(10)
Â  Â  mapping_table = {
Â  Â  Â  Â  (0,0,0,0): factor * (-3-3j), (0,0,0,1): factor * (-3-1j), (0,0,1,1): factor * (-3+1j), (0,0,1,0): factor * (-3+3j),
Â  Â  Â  Â  (0,1,0,0): factor * (-1-3j), (0,1,0,1): factor * (-1-1j), (0,1,1,1): factor * (-1+1j), (0,1,1,0): factor * (-1+3j),
Â  Â  Â  Â  (1,1,0,0): factor * (1-3j), (1,1,0,1): factor * (1-1j), (1,1,1,1): factor * (1+1j), (1,1,1,0): factor * (1+3j),
Â  Â  Â  Â  (1,0,0,0): factor * (3-3j), (1,0,0,1): factor * (3-1j), (1,0,1,1): factor * (3+1j), (1,0,1,0): factor * (3+3j)
Â  Â  }
Â  Â  demapping_table = {v:k for k,v in mapping_table.items()}
elif mod_scheme == "64QAM":
Â  Â  mu = 6
Â  Â  factor = 1.0 / np.sqrt(42)
Â  Â  levels = np.array([-7, -5, -3, -1, 1, 3, 5, 7])
Â  Â  gray_map = [0b000, 0b001, 0b011, 0b010, 0b110, 0b111, 0b101, 0b100]
Â  Â  mapping_table = {}
Â  Â  for pos_i in range(8):
Â  Â  Â  Â  gray_int_i = gray_map[pos_i]
Â  Â  Â  Â  bits_i = ((gray_int_i >> 2) & 1, (gray_int_i >> 1) & 1, gray_int_i & 1)
Â  Â  Â  Â  for pos_j in range(8):
Â  Â  Â  Â  Â  Â  gray_int_j = gray_map[pos_j]
Â  Â  Â  Â  Â  Â  bits_j = ((gray_int_j >> 2) & 1, (gray_int_j >> 1) & 1, gray_int_j & 1)
Â  Â  Â  Â  Â  Â  bits = bits_i + bits_j
Â  Â  Â  Â  Â  Â  I = levels[pos_i]
Â  Â  Â  Â  Â  Â  Q = levels[pos_j]
Â  Â  Â  Â  Â  Â  mapping_table[bits] = factor * (I + 1j * Q)
Â  Â  demapping_table = {v: k for k, v in mapping_table.items()}
else:
Â  Â  mu = 2
Â  Â  factor = 1.0/np.sqrt(2)
Â  Â  mapping_table = {
Â  Â  Â  Â  (0,0): factor * (-1-1j), (0,1): factor * (-1+1j),
Â  Â  Â  Â  (1,0): factor * (1-1j), (1,1): factor * (1+1j)
Â  Â  }
Â  Â  demapping_table = {v:k for k,v in mapping_table.items()}

payloadBits_per_OFDM = len(dataCarriers) * mu

try:
Â  Â  K_db = float(${k_db})
except:
Â  Â  K_db = 10.0
try:
Â  Â  doppler_norm = float(${doppler_norm})
except:
Â  Â  doppler_norm = 0.001
try:
Â  Â  symbol_rate_msym = float(${symbol_rate_msym})
except:
Â  Â  symbol_rate_msym = 1.0

channelResponse = np.array([1])

# --- Hamming (7,4) ---
def hamming_encode(data):
Â  Â  # ... (encoding part is unchanged) ...
Â  Â  n = len(data)
Â  Â  num_blocks = (n + 3) // 4
Â  Â  padded = np.pad(data, (0, num_blocks*4 - n), constant_values=0)
Â  Â  encoded = np.zeros(num_blocks*7, dtype=np.uint8)
Â  Â  for i in range(num_blocks):
Â  Â  Â  Â  d = padded[i*4:(i+1)*4]
Â  Â  Â  Â  d1,d2,d3,d4 = d
Â  Â  Â  Â  p1 = d1 ^ d2 ^ d4
Â  Â  Â  Â  p2 = d1 ^ d3 ^ d4
Â  Â  Â  Â  p3 = d2 ^ d3 ^ d4
Â  Â  Â  Â  enc = [p1,p2,d1,p3,d2,d3,d4]
Â  Â  Â  Â  encoded[i*7:(i+1)*7] = enc
Â  Â  return encoded

def hamming_decode(encoded):
Â  Â  n = len(encoded)
Â  Â  num_blocks = n // 7
Â  Â  decoded = np.zeros(num_blocks*4, dtype=np.uint8)
Â  Â  corrected_bits = 0 # FIXED: Initialize counter
Â  Â  for i in range(num_blocks):
Â  Â  Â  Â  r = encoded[i*7:(i+1)*7].copy()
Â  Â  Â  Â  s1 = r[0] ^ r[2] ^ r[4] ^ r[6]
Â  Â  Â  Â  s2 = r[1] ^ r[2] ^ r[5] ^ r[6]
Â  Â  Â  Â  s3 = r[3] ^ r[4] ^ r[5] ^ r[6]
Â  Â  Â  Â  syndrome = s3*4 + s2*2 + s1
Â  Â  Â  Â  if syndrome != 0:
Â  Â  Â  Â  Â  Â  Â  Â  pos = syndrome - 1
Â  Â  Â  Â  Â  Â  Â  Â  if 0 <= pos < 7:
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r[pos] ^= 1
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  corrected_bits += 1 # This line is correct
Â  Â  Â  Â  decoded[i*4:(i+1)*4] = r[[2,4,5,6]]
Â  Â  return decoded, corrected_bits # MODIFIED

# --- RS(255,223) Implementation (GF(2^8)) ---
# ... (All RS helper functions init_gf, gf_mul, poly_mul, etc. are unchanged) ...
RS_N = 255
RS_K = 223
RS_T = (RS_N - RS_K)//2 # 16
GF_EXP = [0]*512
GF_LOG = [0]*256
def init_gf():
Â  Â  x = 1
Â  Â  for i in range(255):
Â  Â  Â  Â  GF_EXP[i] = x
Â  Â  Â  Â  GF_LOG[x] = i
Â  Â  Â  Â  x <<= 1
Â  Â  Â  Â  if x & 0x100:
Â  Â  Â  Â  Â  Â  x ^= 0x11d
Â  Â  for i in range(255,512):
Â  Â  Â  Â  GF_EXP[i] = GF_EXP[i-255]
init_gf()
def gf_add(a,b): return a ^ b
def gf_sub(a,b): return a ^ b
def gf_mul(a,b):
Â  Â  if a == 0 or b == 0: return 0
Â  Â  return GF_EXP[(GF_LOG[a] + GF_LOG[b]) % 255]
def gf_div(a,b):
Â  Â  if b == 0: raise ZeroDivisionError()
Â  Â  if a == 0: return 0
Â  Â  return GF_EXP[(GF_LOG[a] - GF_LOG[b]) % 255]
def gf_pow(a, power):
Â  Â  if a == 0: return 0
Â  Â  return GF_EXP[(GF_LOG[a]*power) % 255]
def gf_inverse(a):
Â  Â  if a == 0: raise ZeroDivisionError()
Â  Â  return GF_EXP[255 - GF_LOG[a]]
def poly_scale(p, x): return [gf_mul(c, x) for c in p]
def poly_add(p, q):
Â  Â  if len(p) < len(q): p, q = q, p
Â  Â  res = p.copy()
Â  Â  offset = len(p) - len(q)
Â  Â  for i, val in enumerate(q): res[i+offset] ^= val
Â  Â  return res
def poly_mul(p, q):
Â  Â  r = [0]*(len(p)+len(q)-1)
Â  Â  for i,a in enumerate(p):
Â  Â  Â  Â  if a==0: continue
Â  Â  Â  Â  for j,b in enumerate(q):
Â  Â  Â  Â  Â  Â  if b==0: continue
Â  Â  Â  Â  Â  Â  r[i+j] ^= gf_mul(a,b)
Â  Â  return r
def rs_generator_poly():
Â  Â  g = [1]
Â  Â  for i in range(1, 2*RS_T+1):
Â  Â  Â  Â  g = poly_mul(g, [1, GF_EXP[i]])
Â  Â  return g
GEN = rs_generator_poly()
def rs_encode_block(data_bytes):
Â  Â  if len(data_bytes) != RS_K: raise ValueError("rs_encode_block expects length RS_K")
Â  Â  msg = list(data_bytes) + [0]*(RS_N - RS_K)
Â  Â  for i in range(RS_K):
Â  Â  Â  Â  coef = msg[i]
Â  Â  Â  Â  if coef != 0:
Â  Â  Â  Â  Â  Â  for j in range(len(GEN)-1):
Â  Â  Â  Â  Â  Â  Â  Â  msg[i+j+1] ^= gf_mul(GEN[j+1], coef)
Â  Â  parity = msg[RS_K:RS_N]
Â  Â  return list(data_bytes) + parity
def rs_compute_syndromes(rx):
Â  Â  synd = []
Â  Â  for j in range(1, 2*RS_T + 1):
Â  Â  Â  Â  s = 0
Â  Â  Â  Â  for i, val in enumerate(rx):
Â  Â  Â  Â  Â  Â  if val != 0:
Â  Â  Â  Â  Â  Â  Â  Â  s ^= gf_mul(val, GF_EXP[(j * i) % 255])
Â  Â  Â  Â  synd.append(s)
Â  Â  return synd
def berlekamp_massey(synd):
Â  Â  C = [1] + [0]*(2*RS_T); B = [1] + [0]*(2*RS_T); L = 0; m = 1; b = 1
Â  Â  for n in range(0, 2*RS_T):
Â  Â  Â  Â  d = synd[n]
Â  Â  Â  Â  for i in range(1, L+1): d ^= gf_mul(C[i], synd[n - i])
Â  Â  Â  Â  if d == 0: m += 1
Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  T = C.copy(); coef = gf_div(d, b)
Â  Â  Â  Â  Â  Â  for i in range(0, 2*RS_T+1 - m):
Â  Â  Â  Â  Â  Â  Â  Â  if i + m < len(C) and i < len(B): C[i + m] ^= gf_mul(coef, B[i])
Â  Â  Â  Â  Â  Â  if 2*L <= n:
Â  Â  Â  Â  Â  Â  Â  Â  L_new = n + 1 - L; B = T; b = d; L = n + 1 - L; m = 1
Â  Â  Â  Â  Â  Â  else: m += 1
Â  Â  return C[:L+1]
def chien_search(locator):
Â  Â  errs = []; L = len(locator)
Â  Â  for i in range(RS_N):
Â  Â  Â  Â  x_inv = GF_EXP[(255 - i) % 255]; val = 0
Â  Â  Â  Â  for j in range(L - 1, -1, -1): val = gf_mul(val, x_inv) ^ locator[j]
Â  Â  Â  Â  if val == 0: errs.append(i)
Â  Â  if len(errs) != (L - 1): return []
Â  Â  return errs
def forney(omega, locator, error_positions):
Â  Â  error_values = []; L = len(locator)
Â  Â  for pos in error_positions:
Â  Â  Â  Â  x_inv = GF_EXP[(255 - pos) % 255]; num = 0
Â  Â  Â  Â  for i in range(len(omega)): num ^= gf_mul(omega[i], gf_pow(x_inv, i))
Â  Â  Â  Â  denom = 0
Â  Â  Â  Â  for i in range(1, L):
Â  Â  Â  Â  Â  Â  if i % 2 == 1: denom ^= gf_mul(locator[i], gf_pow(x_inv, i - 1))
Â  Â  Â  Â  if denom == 0: return []
Â  Â  Â  Â  err_val = gf_div(num, denom)
Â  Â  Â  Â  error_values.append(err_val)
Â  Â  return error_values

def rs_correct_block(rx_block):
Â  Â  if len(rx_block) != RS_N: raise ValueError("rs_correct_block expects length RS_N")
Â  Â  synd = rs_compute_syndromes(rx_block)
Â  Â  if not any(synd): return rx_block[:RS_K], 0 # MODIFIED (0 corrections)
Â  Â  locator = berlekamp_massey(synd)
Â  Â  if len(locator) - 1 > RS_T: return rx_block[:RS_K], -1 # MODIFIED (failure)
Â  Â  error_positions = chien_search(locator)
Â  Â  if not error_positions or len(error_positions) != len(locator) - 1:
Â  Â  Â  Â  return rx_block[:RS_K], -1 # MODIFIED (failure)
Â  Â  S_poly = synd 
Â  Â  omega_poly = poly_mul(list(reversed(locator)), list(reversed(S_poly)))
Â  Â  omega_poly = list(reversed(omega_poly))
Â  Â  omega = ([0] * (2*RS_T))
Â  Â  for i in range(min(len(omega_poly), 2*RS_T)): omega[i] = omega_poly[i]
Â  Â  error_magnitudes = forney(omega, locator, error_positions)
Â  Â  if not error_magnitudes: return rx_block[:RS_K], -1 # MODIFIED (failure)
Â  Â  corrected = list(rx_block)
Â  Â  for i in range(len(error_positions)):
Â  Â  Â  Â  pos = error_positions[i]; val = error_magnitudes[i]
Â  Â  Â  Â  if pos < len(corrected): corrected[pos] ^= val
Â  Â  if any(rs_compute_syndromes(corrected)):
Â  Â  Â  Â  return rx_block[:RS_K], -1 # MODIFIED (failure)
Â  Â  return corrected[:RS_K], len(error_positions) # MODIFIED (success)

# --- Helper: bytes/bits conversions ---
# ... (bits_to_bytes and bytes_to_bits are unchanged) ...
def bits_to_bytes(bits):
Â  Â  return np.packbits(np.array(bits, dtype=np.uint8))
def bytes_to_bits(arr, desired_bits=None):
Â  Â  b = np.unpackbits(np.array(arr, dtype=np.uint8))
Â  Â  if desired_bits is not None:
Â  Â  Â  Â  return b[:desired_bits]
Â  Â  return b

# --- OFDM functions ---
# ... (SP, Mapping, OFDM_symbol, IDFT, addCP are unchanged) ...
def SP(bits):
Â  Â  if len(bits) < len(dataCarriers) * mu:
Â  Â  Â  Â  bits = np.pad(bits, (0, len(dataCarriers) * mu - len(bits)), constant_values=0)
Â  Â  return bits.reshape((len(dataCarriers), mu))
def Mapping(bits):
Â  Â  if mu == 1:
Â  Â  Â  Â  return np.array([mapping_table[tuple(b)] for b in bits])
Â  Â  else:
Â  Â  Â  Â  return np.array([mapping_table[tuple(b)] for b in bits])
def OFDM_symbol(QAM_payload):
Â  Â  symbol = np.zeros(K, dtype=complex)
Â  Â  symbol[pilotCarriers] = pilotValue
Â  Â  symbol[dataCarriers] = QAM_payload
Â  Â  return symbol
def IDFT(OFDM_data):
Â  Â  return np.fft.ifft(OFDM_data)
def addCP(OFDM_time):
Â  Â  return np.hstack([OFDM_time[-CP:], OFDM_time])

# --- Channel functions ---
# ... (rician_fading, channel, removeCP, DFT, channelEstimate, equalize, get_payload are unchanged) ...
def rician_fading(N, K_db):
Â  Â  K_lin = 10**(K_db/10.0)
Â  Â  los = np.sqrt(K_lin/(K_lin+1.0))
Â  Â  nlos = np.sqrt(1.0/(2*(K_lin+1.0))) * (np.random.randn() + 1j*np.random.randn())
Â  Â  phi = np.exp(1j * 2*np.pi*np.random.rand())
Â  Â  h = (los*phi + nlos) * np.ones(N)
Â  Â  return h
def channel(signal, SNR_db, K_db, doppler_norm, channelResponse):
Â  Â  convolved = np.convolve(signal, channelResponse, mode='same')
Â  Â  h = rician_fading(len(convolved), K_db)
Â  Â  faded = convolved * h
Â  Â  t = np.arange(len(faded))
Â  Â  doppler_shift = np.exp(1j * 2*np.pi * doppler_norm * t)
Â  Â  faded = faded * doppler_shift
Â  Â  signal_power = np.mean(np.abs(faded)**2)
Â  Â  sigma2 = signal_power * 10**(-SNR_db/10.0)
Â  Â  noise = np.sqrt(sigma2/2.0) * (np.random.randn(len(faded)) + 1j*np.random.randn(len(faded)))
Â  Â  return faded + noise
def removeCP(signal):
Â  Â  return signal[CP:(CP+K)]
def DFT(x):
Â  Â  return np.fft.fft(x)
def channelEstimate(OFDM_demod):
Â  Â  pilots = OFDM_demod[pilotCarriers]
Â  Â  Hpil = pilots / pilotValue
Â  Â  kind = 'cubic' if len(pilotCarriers) >= 4 else 'linear'
Â  Â  interp_real = interp1d(pilotCarriers, Hpil.real, kind=kind, fill_value='extrapolate')
Â  Â  interp_imag = interp1d(pilotCarriers, Hpil.imag, kind=kind, fill_value='extrapolate')
Â  Â  Hreal = interp_real(np.arange(K))
Â  Â  Himag = interp_imag(np.arange(K))
Â  Â  H = Hreal + 1j*Himag
Â  Â  win = 3
Â  Â  if win > 1:
Â  Â  Â  Â  kernel = np.ones(win) / win
Â  Â  Â  Â  H = np.convolve(H, kernel, mode='same')
Â  Â  return H
def equalize(OFDM_demod, H):
Â  Â  return OFDM_demod / H
def get_payload(equalized):
Â  Â  return equalized[dataCarriers]

# ... (Demapping, MAC, calculate_data_rate are unchanged) ...
def Demapping(QAM):
Â  Â  constellation_values = np.array(list(demapping_table.keys()))
Â  Â  QAM_power = np.mean(np.abs(QAM)**2)
Â  Â  const_power = np.mean(np.abs(constellation_values)**2)
Â  Â  QAM_scaled = QAM * np.sqrt(const_power / QAM_power) if QAM_power > 0 else QAM
Â  Â  dists = np.abs(QAM_scaled.reshape((-1,1)) - constellation_values.reshape((1,-1)))
Â  Â  const_index = dists.argmin(axis=1)
Â  Â  hardDecision = constellation_values[const_index]
Â  Â  bits = np.vstack([demapping_table[c] for c in hardDecision])
Â  Â  return bits, hardDecision
def mac_encapsulate(bits):
Â  Â  length = len(bits)
Â  Â  header = np.array([int(b) for b in bin(length)[2:].zfill(16)], dtype=np.uint8)
Â  Â  data_with_header = np.hstack([header, bits])
Â  Â  crc = zlib.crc32(data_with_header.tobytes())
Â  Â  crc_bits = np.array([int(b) for b in bin(crc)[2:].zfill(32)], dtype=np.uint8)
return np.hstack([data_with_header, crc_bits])
def mac_decapsulate(bits_est):
Â  Â  if len(bits_est) < 48:
Â  Â  Â  Â  return None, "Packet too short"
Â  Â  header = bits_est[:16]
Â  Â  length = int(''.join(map(str, header)), 2)
Â  Â  expected_len = 16 + length + 32
Â  Â  if len(bits_est) < expected_len:
Â  Â  Â  Â  return None, "Incomplete packet based on header"
Â  Â  data = bits_est[16:16+length]
Â  Â  crc_est_bits = bits_est[16+length:16+length+32]
Â  Â  crc_calc = zlib.crc32(bits_est[:16+length].tobytes())
Â  Â  crc_calc_bits_str = bin(crc_calc)[2:].zfill(32)
Â  Â  if ''.join(map(str, crc_est_bits)) != crc_calc_bits_str:
Â  Â  Â  Â  return data, "CRC Mismatch Error!"
Â  Â  return data, None
def calculate_data_rate(K, CP, dataCarriers, mu, fec_type, RS_K, RS_N, symbol_rate_msym):
Â  Â  modulation_rate = len(dataCarriers) * mu
Â  Â  ofdm_efficiency = K / (K + CP)
Â  Â  if fec_type == "hamming":
Â  Â  Â  Â  coding_rate = 4.0 / 7.0
Â  Â  elif fec_type == "reed_solomon":
Â  Â  Â  Â  coding_rate = RS_K / RS_N
Â  Â  else:
Â  Â  Â  Â  coding_rate = 1.0
Â  Â  symbol_rate_s = symbol_rate_msym * 1e6
Â  Â  data_rate = symbol_rate_s * modulation_rate * ofdm_efficiency * coding_rate
Â  Â  return data_rate

# --- Main simulation ---
def run_simulation(input_text, SNR_db, K_db_param, doppler_norm_param, K_subcarriers_param, fec_type, mod_scheme, symbol_rate_msym):
Â  Â  global K, CP, pilotCarriers, dataCarriers, payloadBits_per_OFDM, mu, mapping_table, demapping_table

Â  Â  # ... (Redefining mod params is unchanged) ...
Â  Â  if mod_scheme == "BPSK": mu = 1
Â  Â  elif mod_scheme == "QPSK": mu = 2
Â  Â  elif mod_scheme == "16QAM": mu = 4
Â  Â  elif mod_scheme == "64QAM": mu = 6
Â  Â  else: mu = 2
Â  Â  try:
Â  Â  Â  Â  K = int(K_subcarriers_param)
Â  Â  except:
Â  Â  Â  Â  K = K
Â  Â  K = K if K>0 and (K & (K-1))==0 else K
Â  Â  CP = K//4
Â  Â  pilotCarriers = np.arange(K)[::max(1, K//P)]
Â  Â  if pilotCarriers[-1] != K-1:
Â  Â  Â  Â  pilotCarriers = np.hstack([pilotCarriers, np.array([K-1])])
Â  Â  dataCarriers = np.delete(np.arange(K), pilotCarriers)
Â  Â  payloadBits_per_OFDM = len(dataCarriers)*mu
Â  Â  K_db = K_db_param
Â  Â  doppler_norm = doppler_norm_param

Â  Â  # ... (Data rate calculation is unchanged) ...
Â  Â  data_rate_bps = calculate_data_rate(K, CP, dataCarriers, mu, fec_type, RS_K, RS_N, symbol_rate_msym)
Â  Â  if data_rate_bps >= 1e9:
Â  Â  Â  Â  rate_str = f"{data_rate_bps/1e9:.2f} Gbps"
Â  Â  elif data_rate_bps >= 1e6:
Â  Â  Â  Â  rate_str = f"{data_rate_bps/1e6:.2f} Mbps"
Â  Â  else:
Â  Â  Â  Â  rate_str = f"{data_rate_bps:.0f} bps"

Â  Â  captured = CapturedOutput()
Â  Â  sys.stdout = captured

Â  Â  # ... (Printing config is unchanged) ...
Â  Â  print('--- Configuration ---')
Â  Â  print(f'Symbol Rate (F_s): {symbol_rate_msym} MSym/s')
Â  Â  print(f'Modulation: {mod_scheme} ({mu} bits/sym)')
Â  Â  print(f'Subcarriers (K): {K} | CP: {CP} (Efficiency: {K/(K+CP):.3f})')
Â  Â  print(f'Data Carriers: {len(dataCarriers)} | Pilots: {len(pilotCarriers)}')
Â  Â  print(f'Rician K-factor (dB): {K_db} | Doppler: {doppler_norm}')
Â  Â  print(f'FEC: {fec_type} (Rate: {4/7:.3f} for Hamming, {RS_K/RS_N:.3f} for RS)')
Â  Â  print('---------------------')

Â  Â  # ... (Text to bits and MAC encapsulation is unchanged) ...
Â  Â  bits = []
Â  Â  for ch in input_text:
Â  Â  Â  Â  b = bin(ord(ch))[2:].zfill(8)
Â  Â  Â  Â  bits.extend([int(x) for x in b])
Â  Â  bits = np.array(bits, dtype=np.uint8)
Â  Â  bits_encap = mac_encapsulate(bits)

Â  Â  # FEC encoding
Â  Â  # FIXED: Removed total_corrected and fec_failed from here
Â  Â  if fec_type == "reed_solomon":
Â  Â  Â  Â  data_bytes = bits_to_bytes(bits_encap)
Â  Â  Â  Â  blocks = []
Â  Â  Â  Â  for i in range(0, len(data_bytes), RS_K):
Â  Â  Â  Â  Â  Â  chunk = data_bytes[i:i+RS_K].tolist()
Â  Â  Â  Â  Â  Â  if len(chunk) < RS_K:
Â  Â  Â  Â  Â  Â  Â  Â  chunk = chunk + [0]*(RS_K - len(chunk))
Â  Â  Â  Â  Â  Â  enc = rs_encode_block(chunk)
Â  Â  Â  Â  Â  Â  blocks.extend(enc)
Â  Â  Â  Â  encoded_bytes = np.array(blocks, dtype=np.uint8)
Â  Â  Â  Â  bits_coded = bytes_to_bits(encoded_bytes)
Â  Â  else:
Â  Â  Â  Â  bits_coded = hamming_encode(bits_encap)

Â  Â  # transmit via OFDM symbol by symbol
Â  Â  num_symbols = int(np.ceil(len(bits_coded) / payloadBits_per_OFDM))
Â  Â  bits_padded = np.pad(bits_coded, (0, num_symbols*payloadBits_per_OFDM - len(bits_coded)))
Â  Â  bits_est_all = np.array([], dtype=np.uint8)
Â  Â  last_QAM_est = None
Â  Â  last_hardDecision = None
Â  Â  last_Hest = None # NEW: Initialize last_Hest

Â  Â  for i in range(num_symbols):
Â  Â  Â  Â  # ... (OFDM modulation is unchanged) ...
Â  Â  Â  Â  bits_sym = bits_padded[i*payloadBits_per_OFDM:(i+1)*payloadBits_per_OFDM]
Â  Â  Â  Â  bits_SP = SP(bits_sym)
Â  Â  Â  Â  QAM = Mapping(bits_SP)
Â  Â  Â  Â  OFDM_data = OFDM_symbol(QAM)
Â  Â  Â  Â  OFDM_time = IDFT(OFDM_data)
Â  Â  Â  Â  OFDM_withCP = addCP(OFDM_time)
Â  Â  Â  Â  
Â  Â  Â  Â  # ... (Channel and reception is unchanged) ...
Â  Â  Â  Â  OFDM_RX = channel(OFDM_withCP, SNR_db, K_db, doppler_norm, channelResponse)
Â  Â  Â  Â  OFDM_RX_comp = OFDM_RX
Â  Â  Â  Â  OFDM_RX_noCP = removeCP(OFDM_RX_comp)
Â  Â  Â  Â  OFDM_demod = DFT(OFDM_RX_noCP)
Â  Â  Â  Â  Hest = channelEstimate(OFDM_demod)
Â  Â  Â  Â  equalized = equalize(OFDM_demod, Hest)
Â  Â  Â  Â  QAM_est = get_payload(equalized)
Â  Â  Â  Â  bits_est_sym, hardDecision = Demapping(QAM_est)
Â  Â  Â  Â  bits_est_all = np.hstack([bits_est_all, bits_est_sym.reshape(-1)])
Â  Â  Â  Â  
Â  Â  Â  Â  # ... (Saving last symbol's data is unchanged) ...
Â  Â  Â  Â  last_QAM_est = QAM_est
Â  Â  Â  Â  last_hardDecision = hardDecision
Â  Â  Â  Â  if i == num_symbols - 1:
Â  Â  Â  Â  Â  Â  last_Hest = Hest


Â  Â  bits_coded_est = bits_est_all[:len(bits_coded)]
Â  Â  Hest = last_Hest # This line was correct

Â  Â  # FEC decode
Â  Â  total_corrected = 0 # NEW: Initialize counters here
Â  Â  fec_failed = False Â  Â # NEW: Initialize flag here

Â  Â  if fec_type == "reed_solomon":
Â  Â  Â  Â  est_bytes = bits_to_bytes(bits_coded_est)
Â  Â  Â  Â  dec_bytes = []
Â  Â  Â  Â  for i in range(0, len(est_bytes), RS_N):
Â  Â  Â  Â  Â  Â  block = est_bytes[i:i+RS_N].tolist()
Â  Â  Â  Â  Â  Â  if len(block) < RS_N:
Â  Â  Â  Â  Â  Â  Â  Â  block = block + [0]*(RS_N - len(block))
Â  Â  Â  Â  Â  Â  data_out, corrections = rs_correct_block(block) # MODIFIED
Â  Â  Â  Â  Â  Â  if corrections == -1: # MODIFIED
Â  Â  Â  Â  Â  Â  Â  Â  fec_failed = True
Â  Â  Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  Â  Â  total_corrected += corrections # MODIFIED
Â  Â  Â  Â  Â  Â  dec_bytes.extend(data_out)
Â  Â  Â  Â  Â  Â  # FIXED: Removed the 'decode_ok' logic, it's redundant with fec_failed
Â  Â  Â  Â  dec_bytes = np.array(dec_bytes[: (len(bits_encap) // 8)], dtype=np.uint8)
Â  Â  Â  Â  bits_encap_est = bytes_to_bits(dec_bytes, desired_bits=len(bits_encap))
Â  Â  Â  Â  bits_encap_est = bits_encap_est[:len(bits_encap)]
Â  Â  else:
Â  Â  Â  Â  bits_encap_est, total_corrected = hamming_decode(bits_coded_est) # MODIFIED
Â  Â  Â  Â  bits_encap_est = bits_encap_est[:len(bits_encap)]

Â  Â  bits_decap, err_msg = mac_decapsulate(bits_encap_est)
Â  Â  if err_msg:
Â  Â  Â  Â  fec_failed = True # If CRC fails, FEC effectively failed

Â  Â  # ... (Printing results is unchanged) ...
Â  Â  print('--- Simulation Results ---')
Â  Â  print(f"Original Message: '{input_text}'")
Â  Â  if err_msg:
Â  Â  Â  Â  print(f"Decoded Message: FAILED! ({err_msg})")
Â  Â  Â  Â  out_text = ''
Â  Â  Â  Â  if (bits_decap is not None):
Â  Â  Â  Â  Â  Â  for i in range(len(bits_decap)//8):
Â  Â  Â  Â  Â  Â  Â  Â  byte = bits_decap[i*8:(i+1)*8]
Â  Â  Â  Â  Â  Â  Â  Â  out_text += chr(int(''.join(map(str, byte)), 2))
Â  Â  Â  Â  Â  Â  print(f"Bad message: '{out_text}'")
Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  print("Message to messed up to decode")
Â  Â  else:
Â  Â  Â  Â  out_text = ''
Â  Â  Â  Â  for i in range(len(bits_decap)//8):
Â  Â  Â  Â  Â  Â  byte = bits_decap[i*8:(i+1)*8]
Â  Â  Â  Â  Â  Â  out_text += chr(int(''.join(map(str, byte)), 2))
Â  Â  Â  Â  print(f"Decoded Message: '{out_text}'")

Â  Â  ber = np.sum(bits_encap != bits_encap_est) / len(bits_encap)
Â  Â  print(f"Bit Error Rate (BER): {ber:.6f}")

Â  Â  # plot
Â  Â  # ... (Constellation plot generation is unchanged) ...
Â  Â  fig, ax = plt.subplots(figsize=(6,6))
Â  Â  if last_QAM_est is not None:
Â  Â  Â  Â  if mod_scheme == "BPSK":
Â  Â  Â  Â  Â  Â  ax.plot(last_QAM_est.real, np.zeros_like(last_QAM_est.real), '.', alpha=0.5, label='Received')
Â  Â  Â  Â  Â  Â  ax.plot(last_hardDecision.real, np.zeros_like(last_hardDecision.real), 'ro', markersize=6, label='Decided')
Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  ax.plot(last_QAM_est.real, last_QAM_est.imag, '.', alpha=0.5, label='Received')
    ax.plot(last_hardDecision.real, last_hardDecision.imag, 'ro', markersize=6, label='Decided')
Â  Â  ax.grid(True)
Â  Â  ax.set_xlabel('I')
Â  Â  ax.set_ylabel('Q')
Â  Â  ax.set_title(f'{mod_scheme} Constellation (SNR={SNR_db} dB, K={K_db} dB)')
Â  Â  ax.legend()
Â  Â  max_const_val = np.max(np.abs(list(mapping_table.values())))
Â  Â  max_plot_val = max_const_val * 1.5 
Â  Â  if mod_scheme == "BPSK":
Â  Â  Â  Â  ax.set_xlim([-max_plot_val, max_plot_val])
Â  Â  Â  Â  ax.set_ylim([-max_plot_val, max_plot_val])
Â  Â  Â  Â  ax.set_aspect('equal')
Â  Â  else:
Â  Â  Â  Â  ax.set_xlim([-max_plot_val, max_plot_val])
Â  Â  Â  Â  ax.set_ylim([-max_plot_val, max_plot_val])
Â  Â  Â  Â  ax.set_aspect('equal')
Â  Â  buf = io.BytesIO()
Â  Â  fig.savefig(buf, format='png', bbox_inches='tight')
Â  Â  buf.seek(0)
Â  Â  plot_b64 = base64.b64encode(buf.read()).decode('utf-8')

Â  Â  # --- VIZ 3: CHANNEL PLOT (NEW) ---
Â  Â  fig_ch, ax_ch = plt.subplots(figsize=(6, 4))
Â  Â  if 'Hest' in locals() and Hest is not None:
Â  Â  Â  Â  Hest_gain_dB = 20 * np.log10(np.abs(Hest))
Â  Â  Â  Â  ax_ch.plot(np.arange(K), Hest_gain_dB, 'b-')
Â  Â  Â  Â  ax_ch.set_title(f'Est. Channel Response (K={K_db} dB)')
Â  Â  Â  Â  ax_ch.set_xlabel('Subcarrier Index')
Â  Â  Â  Â  ax_ch.set_ylabel('Gain (dB)')
Â  Â  Â  Â  ax_ch.grid(True)
Â  Â  Â  Â  ax_ch.set_ylim([np.min(Hest_gain_dB) - 5, np.max(Hest_gain_dB) + 5])
Â  Â  else:
Â  Â  Â  Â  ax_ch.text(0.5, 0.5, 'Channel plot not available.', horizontalalignment='center', verticalalignment='center')
Â  Â  buf_ch = io.BytesIO()
Â  Â  fig_ch.savefig(buf_ch, format='png', bbox_inches='tight')
Â  Â  buf_ch.seek(0)
Â  Â  plot_ch_b64 = base64.b64encode(buf_ch.read()).decode('utf-8')

Â  Â  # --- VIZ 4: FEC STATS (NEW) ---
Â  Â  fec_stats = {
Â  Â  Â  Â  "corrected": total_corrected,
Â  Â  Â  Â  "failed": fec_failed
Â  Â  }
Â  Â  fec_stats_json = json.dumps(fec_stats)

Â  Â  sys.stdout = sys.__stdout__
Â  Â  
Â  Â  # --- NEW RETURN STATEMENT ---
Â  Â  return ( captured.content, plot_b64, rate_str, plot_ch_b64, fec_stats_json, 
Â  Â  Â  Â  Â  Â  Â pilotCarriers.tolist(), dataCarriers.tolist(), mod_scheme )

# Run simulation with injected args (escape message safely)
# Run simulation
run_simulation(
Â  Â  f"""${message.replace(/\\\\/g, '\\\\\\\\').replace(/"/g, '\\\\"')}""",
Â  Â  float(${snr}), float(${k_db}), float(${doppler_norm}), int(${k_subcarriers}),
Â  Â  "${fec_type}", "${mod_scheme}", float(${symbol_rate_msym})
)
`;
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // NEW: Get all 8 return values from Python
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const results = await py.runPythonAsync(pythonCode);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const [
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  outputText, 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  plotBase64, 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  rateStr, 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  plotChBase64, 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  fecStatsJson,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pilotCarriers,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  dataCarriers,
Â  Â  Â  Â  Â  Â  Â  Â      Â  Â  modScheme
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ] = results.toJs();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const fecStats = JSON.parse(fecStatsJson);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Update the original outputs
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  outputDiv.innerText = outputText;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('data-rate-output').innerText = `Effective Data Rate: ${rateStr}`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('plot').src = `data:image/png;base64,${plotBase64}`;
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // --- VIZ 1: ENCODING (NEW) ---
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const encodingViz = document.getElementById('viz-encoding');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const originalBytes = message.length;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const macBytes = originalBytes + 6; // 16bit header + 32bit CRC = 48 bits = 6 bytes
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let fecBytes, fecLabel;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (fec_type === 'hamming') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  fecBytes = Math.ceil((macBytes * 8) * (7 / 4) / 8);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  fecLabel = `Hamming (7,4) Encoded`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const numBlocks = Math.ceil(macBytes / 223); // 223 = RS_K
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  fecBytes = numBlocks * 255; // 255 = RS_N
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  fecLabel = `Reed-Solomon (255,223) Encoded`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const total = fecBytes > 0 ? fecBytes : 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const originalPct = (originalBytes / total * 100).toFixed(1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const macPct = (macBytes / total * 100).toFixed(1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const fecPct = (fecBytes / total * 100).toFixed(1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  encodingViz.innerHTML = `
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div class="data-block" style="width: ${originalPct}%; background-color: #28a745;">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Msg (${originalBytes} B)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div class="data-block" style="width: ${macPct}%; background-color: #17a2b8;">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  +MAC Header/CRC (${macBytes} B)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div class="data-block" style="width: ${fecPct}%; background-color: #ffc107; color: #333;">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ${fecLabel} (${fecBytes} B)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <p>Total bytes to transmit: <strong>${fecBytes}</strong></p>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // --- VIZ 2: OFDM GRID (NEW) ---
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const gridViz = document.getElementById('viz-ofdm-grid');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const k_total_subcarriers = pilotCarriers.length + dataCarriers.length;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const gridCols = Math.ceil(Math.sqrt(k_total_subcarriers));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gridViz.style.gridTemplateColumns = `repeat(${gridCols}, 1fr)`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gridViz.innerHTML = '';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const pilotMap = new Set(pilotCarriers);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const dataMap = new Set(dataCarriers);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let i = 0; i < k_total_subcarriers; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const cell = document.createElement('div');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â    Â  cell.className = 'grid-cell';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let innerHtml = '';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (pilotMap.has(i)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  innerHtml = `<div class="grid-cell-inner cell-pilot" title="Pilot Carrier ${i}">P</div>`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (dataMap.has(i)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  innerHtml = `<div class="grid-cell-inner cell-data" title="Data Carrier ${i} (${modScheme})">${modScheme[0]}</div>`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cell.innerHTML = innerHtml;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gridViz.appendChild(cell);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // --- VIZ 3: CHANNEL PLOT (NEW) ---
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('plot-channel').src = `data:image/png;base64,${plotChBase64}`;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // --- VIZ 4: DECODING (FEC) (NEW) ---
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const decodingViz = document.getElementById('viz-decoding');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let fecUnit = (fec_type === 'hamming') ? 'bits' : 'bytes';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let statusHtml = '';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (fecStats.failed) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  statusHtml = `
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <h3>Status: <span style="color: #dc3545;">FEC FAILED</span></h3>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <p>Too many errors from the channel (SNR too low or fading too deep).</p>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <p>The ${fec_type} decoder was overwhelmed and could not recover the data.</p>
 Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  statusHtml = `
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <h3>Status: <span style="color: #28a745;">Success!</span></h3>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <p>The <strong>${fec_type}</strong> decoder successfully corrected 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <strong>${fecStats.corrected}</strong> ${fecUnit}!</p>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <p>Original message was recovered.</p>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  decodingViz.innerHTML = statusHtml;

Â  Â  Â  Â  Â  Â  Â  Â  } catch (error) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  outputDiv.innerText = `An error occurred during the Python execution:\n${error.message}`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('data-rate-output').innerText = "Effective Data Rate: ERROR";
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  </script>
</body>
</html>