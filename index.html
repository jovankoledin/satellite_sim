<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>OFDM Satellite Simulation</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.26.2/full/pyodide.js"></script>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; max-width: 900px; margin: 0 auto; padding: 20px; background-color: #f4f7f9; color: #333; }
        h1 { color: #0056b3; }
        label { font-weight: bold; display: block; margin-top: 10px; }
        input, button, select { margin: 5px 0 10px 0; padding: 10px; border-radius: 5px; border: 1px solid #ccc; width: calc(100% - 22px); box-sizing: border-box; }
        button { background-color: #007bff; color: white; font-weight: bold; cursor: pointer; transition: background-color 0.3s; }
        button:hover { background-color: #0056b3; }
        #output { background-color: #e9ecef; padding: 15px; border-radius: 5px; white-space: pre-wrap; font-family: "Courier New", Courier, monospace; margin-top: 15px; min-height: 120px; }
        #plot { max-width: 100%; border: 1px solid #ddd; margin-top: 15px; border-radius: 5px; }
        .input-group { display: flex; flex-wrap: wrap; justify-content: space-between; gap:10px; }
        .input-group > div { flex: 1 1 30%; min-width: 200px; }
    </style>
</head>
<body>
    <h1>OFDM Satellite Communication Simulation üõ∞Ô∏è</h1>
    <p>This tool simulates sending a text message over a satellite link using OFDM. It models noise, fading, Doppler and lets you choose FEC (Hamming or RS).</p>

    <h2>Simulation Parameters</h2>
    <div class="input-group">
        <div>
            <label for="message">Message:</label>
            <input type="text" id="message" value="Hello from Earth!">
        </div>
        <div>
            <label for="snr">SNR (dB):</label>
            <input type="number" id="snr" value="25" step="1">
        </div>
        <div>
           <label for="k_db">Rician K-factor (K<sub>dB</sub>):</label>
            <input type="number" id="k_db" value="20" step="1" min="0">
        </div>
        <div>
            <label for="doppler_norm">Normalized Doppler (f<sub>d</sub> / F<sub>s</sub>):</label>
            <input type="number" id="doppler_norm" value="0.000" step="0.0001" min="0">
        </div>
        <div>
            <label for="k_subcarriers">Number of Subcarriers (K):</label>
            <input type="number" id="k_subcarriers" value="64" step="16" min="16">
        </div>
        <div>
            <label for="fec_type">FEC Scheme:</label>
            <select id="fec_type">
                <option value="hamming">Hamming (7,4)</option>
                <option value="reed_solomon">Reed-Solomon (255,223)</option>
            </select>
        </div>
    </div>

    <button onclick="runSimulation()">Run Simulation</button>

    <div id="output">Simulation results will appear here...</div>
    <img id="plot" src="" alt="Constellation Diagram">

    <script type="text/javascript">
        let pyodide;
        const outputDiv = document.getElementById('output');
        outputDiv.innerText = "Initializing Pyodide and loading packages... This may take a moment. ‚è≥";

        async function loadPyodideAndPackages() {
            pyodide = await loadPyodide();
            await pyodide.loadPackage(['numpy','matplotlib','scipy']);
            outputDiv.innerText = "Ready to run simulation. ‚úÖ";
            return pyodide;
        }
        const pyodidePromise = loadPyodideAndPackages();

        async function runSimulation() {
            outputDiv.innerText = "Running simulation, please wait... ‚öôÔ∏è";
            document.getElementById('plot').src = "";

            const py = await pyodidePromise;

            const snr = document.getElementById('snr').value;
            const message = document.getElementById('message').value;
            const k_db = document.getElementById('k_db').value;
            const doppler_norm = document.getElementById('doppler_norm').value;
            const k_subcarriers = document.getElementById('k_subcarriers').value;
            const fec_type = document.getElementById('fec_type').value;

            const pythonCode = `
import numpy as np
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import zlib, io, base64, sys

class CapturedOutput:
    def __init__(self):
        self.content = ''
    def write(self, text):
        self.content += text
    def flush(self):
        pass

# --- Simulation parameters from JS ---
try:
    K = int(${k_subcarriers})
except:
    K = 64
K = K if K>0 and (K & (K-1) == 0) else 64
CP = K // 4
pilotValue = 1+1j
P = 4
allCarriers = np.arange(K)
pilotCarriers = allCarriers[::max(1, K//P)]
if allCarriers[-1] not in pilotCarriers:
    pilotCarriers = np.hstack([pilotCarriers, np.array([allCarriers[-1]])])
dataCarriers = np.delete(allCarriers, pilotCarriers)
mu = 2
payloadBits_per_OFDM = len(dataCarriers) * mu

try:
    K_db = float(${k_db})
except:
    K_db = 10.0
try:
    doppler_norm = float(${doppler_norm})
except:
    doppler_norm = 0.001

channelResponse = np.array([1, 0, 0.3+0.3j])

mapping_table = {
    (0,0): -1-1j, (0,1): -1+1j,
    (1,0): 1-1j, (1,1): 1+1j
}
demapping_table = {v:k for k,v in mapping_table.items()}

# --- Hamming (7,4) ---
def hamming_encode(data):
    n = len(data)
    num_blocks = (n + 3) // 4
    padded = np.pad(data, (0, num_blocks*4 - n), constant_values=0)
    encoded = np.zeros(num_blocks*7, dtype=np.uint8)
    for i in range(num_blocks):
        d = padded[i*4:(i+1)*4]
        d1,d2,d3,d4 = d
        p1 = d1 ^ d2 ^ d4
        p2 = d1 ^ d3 ^ d4
        p3 = d2 ^ d3 ^ d4
        enc = [p1,p2,d1,p3,d2,d3,d4]
        encoded[i*7:(i+1)*7] = enc
    return encoded

def hamming_decode(encoded):
    n = len(encoded)
    num_blocks = n // 7
    decoded = np.zeros(num_blocks*4, dtype=np.uint8)
    for i in range(num_blocks):
        r = encoded[i*7:(i+1)*7].copy()
        s1 = r[0] ^ r[2] ^ r[4] ^ r[6]
        s2 = r[1] ^ r[2] ^ r[5] ^ r[6]
        s3 = r[3] ^ r[4] ^ r[5] ^ r[6]
        syndrome = s3*4 + s2*2 + s1
        if syndrome != 0:
            pos = syndrome - 1
            if 0 <= pos < 7:
                r[pos] ^= 1
        decoded[i*4:(i+1)*4] = r[[2,4,5,6]]
    return decoded

# --- RS(255,223) Implementation (GF(2^8)) ---
RS_N = 255
RS_K = 223
RS_T = (RS_N - RS_K)//2  # 16

# Precompute GF(2^8) exp/log tables using primitive 0x11d
GF_EXP = [0]*512
GF_LOG = [0]*256
def init_gf():
    x = 1
    for i in range(255):
        GF_EXP[i] = x
        GF_LOG[x] = i
        x <<= 1
        if x & 0x100:
            x ^= 0x11d
    for i in range(255,512):
        GF_EXP[i] = GF_EXP[i-255]
init_gf()

def gf_add(a,b):
    return a ^ b
def gf_sub(a,b):
    return a ^ b
def gf_mul(a,b):
    if a == 0 or b == 0:
        return 0
    return GF_EXP[(GF_LOG[a] + GF_LOG[b]) % 255]
def gf_div(a,b):
    if b == 0:
        raise ZeroDivisionError()
    if a == 0:
        return 0
    return GF_EXP[(GF_LOG[a] - GF_LOG[b]) % 255]
def gf_pow(a, power):
    if a == 0:
        return 0
    return GF_EXP[(GF_LOG[a]*power) % 255]
def gf_inverse(a):
    if a == 0:
        raise ZeroDivisionError()
    return GF_EXP[255 - GF_LOG[a]]

def poly_scale(p, x):
    return [gf_mul(c, x) for c in p]
def poly_add(p, q):
    # XOR add
    if len(p) < len(q):
        p, q = q, p
    res = p.copy()
    offset = len(p) - len(q)
    for i, val in enumerate(q):
        res[i+offset] ^= val
    return res

def poly_mul(p, q):
    r = [0]*(len(p)+len(q)-1)
    for i,a in enumerate(p):
        if a==0: continue
        for j,b in enumerate(q):
            if b==0: continue
            r[i+j] ^= gf_mul(a,b)
    return r

# generator polynomial: g(x) = (x - alpha^1)(x - alpha^2)...(x - alpha^(2t))
def rs_generator_poly():
    g = [1]
    for i in range(1, 2*RS_T+1):
        g = poly_mul(g, [1, GF_EXP[i]])
    return g

GEN = rs_generator_poly()

def rs_encode_block(data_bytes):
    # data_bytes: list/array of length RS_K
    if len(data_bytes) != RS_K:
        raise ValueError("rs_encode_block expects length RS_K")
    msg = list(data_bytes) + [0]*(RS_N - RS_K)
    # polynomial long division by generator
    for i in range(RS_K):
        coef = msg[i]
        if coef != 0:
            for j in range(len(GEN)-1):
                msg[i+j+1] ^= gf_mul(GEN[j+1], coef)
    # remainder are parity bytes appended after data
    parity = msg[RS_K:RS_N]
    return list(data_bytes) + parity

def rs_compute_syndromes(rx):
    # rx: length RS_N
    synd = []
    for i in range(1, 2*RS_T+1):
        s = 0
        for j, val in enumerate(rx):
            if val != 0:
                s ^= gf_mul(val, GF_EXP[(i * (RS_N - 1 - j)) % 255])
        synd.append(s)
    return synd

# Berlekamp-Massey to find error locator polynomial
def berlekamp_massey(synd):
    # synd: list of length 2t
    C = [1] + [0]*(2*RS_T)
    B = [1] + [0]*(2*RS_T)
    L = 0
    m = 1
    b = 1
    for n in range(0, 2*RS_T):
        # compute discrepancy
        d = synd[n]
        for i in range(1, L+1):
            d ^= gf_mul(C[i], synd[n - i])
        if d == 0:
            m += 1
        else:
            T = C.copy()
            coef = gf_div(d, b)
            # C = C - coef * x^m * B
            for i in range(0, 2*RS_T+1 - m):
                if i + m < len(C) and i < len(B):
                    C[i + m] ^= gf_mul(coef, B[i])
            if 2*L <= n:
                L_new = n + 1 - L
                B = T
                b = d
                L = n + 1 - L
                m = 1
            else:
                m += 1
    # trim C to degree L
    return C[:L+1]

def chien_search(locator):
    # find roots of locator polynomial: locator[0] + locator[1]*x + ... ; x = alpha^{-i}
    errs = []
    L = len(locator) - 1
    for i in range(RS_N):
        # evaluate at alpha^{-i}
        x = GF_EXP[(255 - i) % 255]
        val = 0
        for coef in locator:
            val = gf_mul(val, x) ^ coef
        if val == 0:
            # position is RS_N-1 - i (mapping between polynomial index & position)
            errs.append((RS_N - 1 - i))
    return errs

def forney(omega, locator, error_positions):
    # Compute error magnitudes using Forney's algorithm
    error_values = []
    locator_deriv = []
    for i in range(1, len(locator)):
        if i % 2 == 1:
            locator_deriv.append(locator[i])
    for pos in error_positions:
        # compute x = alpha^{-(pos)}
        xi_inv = GF_EXP[(pos) % 255]
        # evaluate omega(x^{-1})
        num = 0
        for i, coef in enumerate(omega):
            num ^= gf_mul(coef, gf_pow(xi_inv, i))
        # evaluate locator_deriv at x^{-1}
        denom = 0
        for i, coef in enumerate(locator_deriv):
            denom ^= gf_mul(coef, gf_pow(xi_inv, i))
        if denom == 0:
            # numerical issue
            error_values.append(0)
        else:
            err = gf_div(num, denom)
            error_values.append(err)
    return error_values

def rs_correct_block(rx_block):
    # rx_block: list length RS_N
    synd = rs_compute_syndromes(rx_block)
    if max(synd) == 0:
        return rx_block[:RS_K], True  # no errors
    # compute error locator polynomial
    locator = berlekamp_massey(synd)
    # find error positions
    error_positions = chien_search(locator)
    if len(error_positions) == 0 or len(error_positions) > RS_T:
        # cannot correct
        return rx_block[:RS_K], False
    # compute error evaluator polynomial omega (using syndromes & locator)
    # omega(x) = synd(x) * locator(x) mod x^{2t}
    # Represent syndromes as polynomial (index 0 is s1)
    S = [0] + list(synd)  # pad to align indexing (s0 unused)
    # convert locator to proper polynomial for multiplication: locator reversed
    # compute Omega by polynomial multiplication then take first (2t) coefficients
    # Build polynomial forms (lowest power first)
    # poly mul
    omega = [0]*(len(locator)+len(S)-2)
    for i, a in enumerate(locator):
        for j in range(len(S)-1):
            omega[i+j] ^= gf_mul(a, S[j+1])
    omega = omega[:2*RS_T]
    # Forney to compute magnitudes
    error_magnitudes = forney(omega, locator, error_positions)
    # Apply corrections
    corrected = rx_block.copy()
    for pos, val in zip(error_positions, error_magnitudes):
        if pos < 0 or pos >= RS_N:
            continue
        corrected[pos] ^= val
    # Recompute syndromes to see if fixed
    new_synd = rs_compute_syndromes(corrected)
    if max(new_synd) != 0:
        return corrected[:RS_K], False
    return corrected[:RS_K], True

# --- Helper: bytes/bits conversions ---
def bits_to_bytes(bits):
    # bits: array of 0/1 length multiple of 8 (pad outside if needed)
    return np.packbits(np.array(bits, dtype=np.uint8))

def bytes_to_bits(arr, desired_bits=None):
    b = np.unpackbits(np.array(arr, dtype=np.uint8))
    if desired_bits is not None:
        return b[:desired_bits]
    return b

# --- OFDM functions ---
def SP(bits):
    return bits.reshape((len(dataCarriers), mu))
def Mapping(bits):
    return np.array([mapping_table[tuple(b)] for b in bits])
def OFDM_symbol(QAM_payload):
    symbol = np.zeros(K, dtype=complex)
    symbol[pilotCarriers] = pilotValue
    symbol[dataCarriers] = QAM_payload
    return symbol
def IDFT(OFDM_data):
    return np.fft.ifft(OFDM_data)
def addCP(OFDM_time):
    return np.hstack([OFDM_time[-CP:], OFDM_time])

def rician_fading(N, K_db):
    K_lin = 10**(K_db/10.0)
    los = np.sqrt(K_lin/(K_lin+1.0))
    nlos = np.sqrt(1.0/(2*(K_lin+1.0))) * (np.random.randn(N) + 1j*np.random.randn(N))
    phi = np.exp(1j * 2*np.pi*np.random.rand())
    return los*phi + nlos

def channel(signal, SNR_db, K_db, doppler_norm, channelResponse):
    convolved = np.convolve(signal, channelResponse, mode='same')
    h = rician_fading(len(convolved), K_db)
    faded = convolved * h
    t = np.arange(len(faded))
    doppler_shift = np.exp(1j * 2*np.pi * doppler_norm * t)
    faded = faded * doppler_shift
    signal_power = np.mean(np.abs(faded)**2)
    sigma2 = signal_power * 10**(-SNR_db/10.0)
    noise = np.sqrt(sigma2/2.0) * (np.random.randn(len(faded)) + 1j*np.random.randn(len(faded)))
    return faded + noise

def removeCP(signal):
    return signal[CP:(CP+K)]
def DFT(x):
    return np.fft.fft(x)

def channelEstimate(OFDM_demod):
    pilots = OFDM_demod[pilotCarriers]
    Hpil = pilots / pilotValue
    Hreal = np.interp(allCarriers, pilotCarriers, Hpil.real)
    Himag = np.interp(allCarriers, pilotCarriers, Hpil.imag)
    H = Hreal + 1j*Himag
    # small smoothing
    win = 3
    if win>1:
        kernel = np.ones(win)/win
        H = np.convolve(H, kernel, mode='same')
    return H

def equalize(OFDM_demod, H):
    return OFDM_demod / H

def get_payload(equalized):
    return equalized[dataCarriers]

def Demapping(QAM):
    constellation = np.array(list(demapping_table.keys()))
    dists = np.abs(QAM.reshape((-1,1)) - constellation.reshape((1,-1)))
    const_index = dists.argmin(axis=1)
    hardDecision = constellation[const_index]
    bits = np.vstack([demapping_table[c] for c in hardDecision])
    return bits, hardDecision

# MAC
def mac_encapsulate(bits):
    length = len(bits)
    header = np.array([int(b) for b in bin(length)[2:].zfill(16)], dtype=np.uint8)
    data_with_header = np.hstack([header, bits])
    crc = zlib.crc32(data_with_header.tobytes())
    crc_bits = np.array([int(b) for b in bin(crc)[2:].zfill(32)], dtype=np.uint8)
    return np.hstack([data_with_header, crc_bits])

def mac_decapsulate(bits_est):
    if len(bits_est) < 48:
        return None, "Packet too short"
    header = bits_est[:16]
    length = int(''.join(map(str, header)), 2)
    expected_len = 16 + length + 32
    if len(bits_est) < expected_len:
        return None, "Incomplete packet based on header"
    data = bits_est[16:16+length]
    crc_est_bits = bits_est[16+length:16+length+32]
    crc_calc = zlib.crc32(bits_est[:16+length].tobytes())
    crc_calc_bits_str = bin(crc_calc)[2:].zfill(32)
    if ''.join(map(str, crc_est_bits)) != crc_calc_bits_str:
        return None, "CRC Mismatch Error!"
    return data, None

# --- Main simulation ---
def run_simulation(input_text, SNR_db, K_db_param, doppler_norm_param, K_subcarriers_param, fec_type):
    global K, CP, pilotCarriers, dataCarriers, payloadBits_per_OFDM
    try:
        K = int(K_subcarriers_param)
    except:
        K = K
    K = K if K>0 and (K & (K-1))==0 else K
    CP = K//4
    pilotCarriers = np.arange(K)[::max(1, K//P)]
    if pilotCarriers[-1] != K-1:
        pilotCarriers = np.hstack([pilotCarriers, np.array([K-1])])
    dataCarriers = np.delete(np.arange(K), pilotCarriers)
    payloadBits_per_OFDM = len(dataCarriers)*mu

    K_db = K_db_param
    doppler_norm = doppler_norm_param

    captured = CapturedOutput()
    sys.stdout = captured

    print('--- Configuration ---')
    print(f'Subcarriers (K): {K}')
    print(f'Data Carriers: {len(dataCarriers)} | Pilots: {len(pilotCarriers)}')
    print(f'Cyclic Prefix (CP): {CP}')
    print(f'Rician K-factor (dB): {K_db}')
    print(f'Normalized Doppler: {doppler_norm}')
    print(f'FEC: {fec_type}')
    print('---------------------')

    bits = []
    for ch in input_text:
        b = bin(ord(ch))[2:].zfill(8)
        bits.extend([int(x) for x in b])
    bits = np.array(bits, dtype=np.uint8)

    bits_encap = mac_encapsulate(bits)

    # FEC encoding
    if fec_type == "reed_solomon":
        # operate in bytes
        data_bytes = bits_to_bytes(bits_encap)
        # break into blocks of RS_K bytes
        blocks = []
        for i in range(0, len(data_bytes), RS_K):
            chunk = data_bytes[i:i+RS_K].tolist()
            if len(chunk) < RS_K:
                chunk = chunk + [0]*(RS_K - len(chunk))
            enc = rs_encode_block(chunk)
            blocks.extend(enc)
        encoded_bytes = np.array(blocks, dtype=np.uint8)
        bits_coded = bytes_to_bits(encoded_bytes)
    else:
        bits_coded = hamming_encode(bits_encap)

    # transmit via OFDM symbol by symbol
    num_symbols = int(np.ceil(len(bits_coded) / payloadBits_per_OFDM))
    bits_padded = np.pad(bits_coded, (0, num_symbols*payloadBits_per_OFDM - len(bits_coded)))
    bits_est_all = np.array([], dtype=np.uint8)
    last_QAM_est = None
    last_hardDecision = None

    for i in range(num_symbols):
        bits_sym = bits_padded[i*payloadBits_per_OFDM:(i+1)*payloadBits_per_OFDM]
        bits_SP = SP(bits_sym)
        QAM = Mapping(bits_SP)
        OFDM_data = OFDM_symbol(QAM)
        OFDM_time = IDFT(OFDM_data)
        OFDM_withCP = addCP(OFDM_time)

        OFDM_RX = channel(OFDM_withCP, SNR_db, K_db, doppler_norm, channelResponse)
        OFDM_RX_comp = OFDM_RX  # we simulated Doppler already

        OFDM_RX_noCP = removeCP(OFDM_RX_comp)
        OFDM_demod = DFT(OFDM_RX_noCP)
        Hest = channelEstimate(OFDM_demod)
        equalized = equalize(OFDM_demod, Hest)
        QAM_est = get_payload(equalized)
        bits_est_sym, hardDecision = Demapping(QAM_est)
        bits_est_all = np.hstack([bits_est_all, bits_est_sym.reshape(-1)])
        last_QAM_est = QAM_est
        last_hardDecision = hardDecision

    bits_coded_est = bits_est_all[:len(bits_coded)]

    # FEC decode
    if fec_type == "reed_solomon":
        est_bytes = bits_to_bytes(bits_coded_est)
        dec_bytes = []
        decode_ok = True
        for i in range(0, len(est_bytes), RS_N):
            block = est_bytes[i:i+RS_N].tolist()
            if len(block) < RS_N:
                block = block + [0]*(RS_N - len(block))
            data_out, ok = rs_correct_block(block)
            dec_bytes.extend(data_out)
            if not ok:
                decode_ok = False
        dec_bytes = np.array(dec_bytes[: (len(bits_encap) // 8)], dtype=np.uint8)
        bits_encap_est = bytes_to_bits(dec_bytes, desired_bits=len(bits_encap))
        bits_encap_est = bits_encap_est[:len(bits_encap)]
    else:
        bits_encap_est = hamming_decode(bits_coded_est)[:len(bits_encap)]

    bits_decap, err_msg = mac_decapsulate(bits_encap_est)
    print('--- Simulation Results ---')
    print(f"Original Message: '{input_text}'")
    if err_msg:
        print(f"Decoded Message: FAILED! ({err_msg})")
    else:
        # bits_decap to text
        out_text = ''
        for i in range(len(bits_decap)//8):
            byte = bits_decap[i*8:(i+1)*8]
            out_text += chr(int(''.join(map(str, byte)), 2))
        print(f"Decoded Message: '{out_text}'")

    ber = np.sum(bits_encap != bits_encap_est) / len(bits_encap)
    print(f"Bit Error Rate (BER): {ber:.6f}")

    # plot
    fig, ax = plt.subplots(figsize=(6,6))
    if last_QAM_est is not None:
        ax.plot(last_QAM_est.real, last_QAM_est.imag, '.', alpha=0.5, label='Received')
    if last_hardDecision is not None:
        ax.plot(last_hardDecision.real, last_hardDecision.imag, 'ro', markersize=6, label='Decided')
    ax.grid(True)
    ax.set_xlabel('I')
    ax.set_ylabel('Q')
    ax.set_title(f'Constellation (SNR={SNR_db} dB, K={K_db} dB)')
    ax.legend()
    max_val = np.max(np.abs(list(mapping_table.values())))*1.5
    ax.set_xlim([-max_val, max_val])
    ax.set_ylim([-max_val, max_val])
    ax.set_aspect('equal')

    buf = io.BytesIO()
    fig.savefig(buf, format='png', bbox_inches='tight')
    buf.seek(0)
    plot_b64 = base64.b64encode(buf.read()).decode('utf-8')

    sys.stdout = sys.__stdout__
    return captured.content, plot_b64

# Run simulation with injected args (escape message safely)
run_simulation(
    f"""${message.replace(/\\\\/g, '\\\\\\\\').replace(/"/g, '\\\\"')}""",
    float(${snr}),
    float(${k_db}),
    float(${doppler_norm}),
    int(${k_subcarriers}),
    "${fec_type}"
)
`;
            try {
                const results = await py.runPythonAsync(pythonCode);
                const [outputText, plotBase64] = results.toJs();
                outputDiv.innerText = outputText;
                document.getElementById('plot').src = `data:image/png;base64,${plotBase64}`;
            } catch (error) {
                outputDiv.innerText = `An error occurred during the Python execution:\n${error.message}`;
            }
        }
    </script>
</body>
</html>
